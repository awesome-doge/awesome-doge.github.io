---
title: 'IBM 029 型打孔機 [轉linux.cn]'
date: 2018-12-27 15:18:11
tags: [linux.cn, IBM]
categories: linux.cn
---

我知道這很學院派，可一行超過 80 個字元的程式碼還是讓我抓狂。我也在網上見過不少人認為即使在現代的視網膜螢幕下也應當採用行長度為 80 個字元的標準，可他們都不理解我對破壞這一標準的怒火，就算多 1 個字元也不行。

在這一標準的黃金時期，一行程式碼的長度幾乎不會超過 80 個字元的限制。在那時，這一限制是物理的，沒有第 81 列用於存放第 81 個字元。每一個試圖把函數名起的又長又臭的程式設計師都會在短暫的愉悅後迎來更多的麻煩，而這僅僅是因為沒有足夠的空間放下整個函數的聲明。

<!-- more --> 

這一黃金時期也是<ruby>打孔卡<rt>punch card</rt></ruby>程式設計時期。在 20 世紀 60 年代，IBM 打孔卡設立了標準，這個標準就是打孔卡的寬度為 80 列。這個 80 列標準在後來的電傳打字機和啞終端時期得以延續，並逐漸成為作業系統中隱藏的細節。時至今日，即使我們用上了更大、更好的螢幕，偏向於使用更長的標識符而不是類似 `iswcntrl()` 這樣令人難以猜測的函數名，可當你開啟新的終端模擬器視窗時，預設的寬度依然是 80 個字元。

從 Quora 上的很多問題中可以發現，很多人並不能想象如何使用打孔卡給計算機程式設計。我承認，在很長的一段時間裡我也不能理解打孔卡程式設計是如何工作的，因為這讓我想到就像勞工一樣不停的給這些打孔卡打孔。當然，這是一個誤解，程式設計師不需要親自給打孔卡打孔，就像是火車排程員不用親自扳道岔。程式設計師們有<ruby>打孔機<rt>card punch machines</rt></ruby>（也被稱為<ruby>鍵控打孔機<rt>key punches</rt></ruby>），這讓他們可以使用打字機式的鍵盤給打孔卡打孔。這樣的裝置在 19 世紀 90 年代時就已經不是什麼新技術了。

那時，最為廣泛使用的打孔機之一便是 IBM 029 型打孔機。就算在今天，它也許是最棒的打孔機。

![][1]

IBM 029 型打孔機在 1964 年作為 IBM 的 System/360 大型電腦的配件發售的。System/360 是計算系統與外設所組成的一個系列，在 20 世紀 60 年代晚期，它幾乎壟斷了整個大型計算機市場。就像其它 System/360 外設一樣，029 型打孔機也是個大塊頭。那時，計算機和傢俱的界限還很模糊，但 029 型打孔機可不是那種會佔領你的整張桌子的機器。它改進自 026 型打孔機，增加了新的字元支援，如括號，總體上也更加安靜。與前輩 026 型所展出 20 世紀 40 年代的圓形按鈕與工業化的樣貌相比，029 型的按鍵方正扁平、功能按鍵還有酷炫的藍色高亮提示。它的另一個重要買點是它能夠在<ruby>數字區<rt>numeric field</rt></ruby>左側自動的填充 0 ，這證明了 JavaScript 程式設計師不是第一批懶得自己做<ruby>左填充<rt>left-padding</rt></ruby>的程式設計師。（LCTT 譯註：這項功能需要額外的 4 張 <ruby>[標準模組系統卡](https://en.wikipedia.org/wiki/IBM_Standard_Modular_System)<rt>SMS card</rt></ruby>才能使用。例如設定數字區域長度為 6 列時，操作員只需要輸入 73 ，打孔機會自動填充起始位置上的 4 個 0 ，故最終輸出 000073。[更多資訊](https://en.wikipedia.org/wiki/Keypunch#IBM_029_Card_Punch)）

等等！你說的是 IBM 在 1964 年釋出了全新的打孔機？你知道那張在貝爾實驗室拍攝的 Unix 之父正在使用電傳打字機的照片嗎？那是哪一年的來著？1970？打孔機不是應該在 20 世紀 60 年代中期到晚期時就過時了嗎？是的，你也許會奇怪，為什麼直到 1984 年，IBM 的產品目錄中還會出現 029 型打孔機的身影 [^1]。事實上，直到 20 世紀 70 年代，大多數程式設計師仍然在使用打孔卡程式設計。其實二戰期間就已經有人在用電傳打字機了，可那時並沒能普及。客觀的講，電傳打字機幾乎和打孔卡一樣古老。也許和你想象的恰恰相反，並不是電傳打字機本身限制了它的普及，而是計算時間。人們拒絕使用電傳打字機的原因是，它是可互動的，它和計算機使用<ruby>“線上”的傳輸方式<rt>"online" mode of communication</rt></ruby>。在以 Unix 為代表的分時作業系統被髮明前，你和電腦的互動會被任何人的使用而打斷，而這一點延遲通常意味著幾千美元的損失。所以程式設計師們普遍選擇離線地使用打孔機程式設計，再將打孔卡放入大型計算機中，作為<ruby>批任務<rt>batch job</rt></ruby>執行。在那時，還沒有即廉價又可靠的儲存裝置，可打孔卡的廉價優勢已經足夠讓它成為那時最流行的資料儲存方式了。那時的程式是書架上一摞打孔卡而不是硬盤裡的一堆檔案。

那麼實際使用 IBM 029 型打孔機是個什麼樣子呢？這很難向沒有實際看過打孔卡的人解釋。一張打孔卡通常有 12 行 80 列。打孔卡下面是從 1 到 9 的<ruby>數字行<rt>digit rows</rt></ruby>，打孔卡上的每一列都有這些行所對應的數字。最上面的三行是<ruby>空間行<rt>"zone" rows</rt></ruby>，通常由兩行空白行和一行 0 行組成。第 12 行是打孔卡最頂部的行，接下來是 11 行，隨後是從數字 0 到 9 所在的行。這個有點讓人感到困惑的順序的原因是打孔卡的上邊緣被稱為<ruby>12 邊<rt>12 edge</rt></ruby>、下邊緣被稱為 <ruby>9 邊<rt>9 edge</rt></ruby>。那時，為了讓打孔卡便於整理，常常會剪去打孔卡的一個角。

![][2]

（LCTT 譯註：可參考[EBCDIC 編碼](https://zh.wikipedia.org/wiki/EBCDIC)）

在打孔卡發明之初，孔洞的形狀是圓形的，但是 IBM 最終意識到如果使用窄長方形作為孔洞，一張卡就可以放下更多的列了。每一列中孔洞的不同組合就可以表達不同的字元。像 029 型這樣的擁有人性化設計的打孔機除了完成本質的打孔任務外，還會在打孔卡最上方打印出每一列所對應的字元。輸入是數字就在對應的數字行上打孔。輸入的是字母或符號就用一個在空間列的孔和一或倆個在數字列的孔的組合表示，例如字母 A 就用一個在第 12 空間行的空和一個數字 1 所在行的孔表示。這是一種順序編碼，在第一臺打孔機被髮明後，也叫 Hollerith 編碼。這種編碼只能表示相對較小的一套字符集，小寫字母就沒有包含在這套字符集中。如今一些聰明的工程師可能想知道為什麼打卡不乾脆使用二進位制編碼 —— 畢竟，有 12 行，你可以編碼超過 4000 個字元。 使用 Hollerith 編碼是因為它確保在單個列中出現不超過三個孔。這保留了卡的結構強度。二進位制編碼會帶來太多的孔，會因為孔洞過於密集而斷裂。

打孔卡也有不同。在 20 世紀 60 年代，80 列雖然是標準，但表達的方式不一定相同。基礎打孔卡是無標註的，但用於 COBOL 程式設計的打孔卡會把最後的 8 列保留，供標識數儲存使用。這一標識數可以在打孔卡被打亂 (例如一疊打孔卡掉在地上了) 後用於自動排序。此外，第 7 列被用於表示本張打孔卡上的是否與上一張打孔卡一起構成一條語句。也就是說當你真的對 80 字元的限制感到絕望的時候，還可以用兩張卡甚至更多的卡拼接成一條長語句。用於 FORTRAN 程式設計的打孔卡和 COBOL 打孔卡類似，但是定義的列不同。大學裡使用的打孔卡通常會由其計算機中心加上水印，其它的設計則會在如 [1976 年美國獨立 200 週年][3] 的特殊場合才會加入。

最終，這些打孔卡都要被計算機讀取和計算。IBM 出售的 System/360 大型計算機的外設 IBM 2540 可以以每分鐘 1000 張打孔卡的速度讀取這些卡片[^2] 。IBM 2540 使用電刷掃過每張打孔卡，電刷通過孔洞就可以接觸到卡片後面的金屬板完成一次讀取。一旦讀取完畢，System/360 大型計算機就會把每張打孔卡上的資料使用一種定長的 8 位編碼儲存，這種編碼是<ruby>擴增二進式十進交換碼<rt>Extended Binary Coded Decimal Interchange Code</rt></ruby>，簡寫為 EBCDIC 編碼。它是一種二進位制編碼，可以追溯自早期打孔卡所使用的 BCDIDC 編碼 —— 其 6 位編碼使用低 4 位表示數字行，高 2 位表示空間行。程式設計師們在打孔卡上編寫完程式後，會把卡片們交給計算機操作員，操作員們會把這些卡片放入 IBM 2540 ，再把列印結果交給程式設計師。那時的程式設計師大多都沒有見過計算機長什麼樣。

程式設計師們真正能見到的是很多打孔機。029 型打孔機雖然不是計算機，但這並不意味著它不是一臺複雜的機器。看看這個由<ruby>密歇根大學<rt>University of Michigan</rt></ruby>計算機中心在 1967 年製作的[教學視訊][4]，你就能更好的理解使用一臺 029 型打孔機是什麼情形了。我會盡可能在這裡總結這段視訊，但如果你不去親自看看的話，你會錯過許多驚奇和感嘆。

029 型打孔機的結構圍繞著一個打孔卡穿過機器的 U 形軌道開始。使用打孔機時，右手邊也就是 U 形軌道的右側頂部是<ruby>進卡卡槽<rt>hopper</rt></ruby>，使用前通常在裡面放入一疊未使用的打孔卡。雖然 029 型打孔機主要使用 80 列打孔卡，但在需要的情況下也可以使用更小號的打孔卡。在打孔機的使用過程中，打孔卡離開軌道右上端的進卡卡槽，順著 U 形軌道移動並最終進入左上端的<ruby>出卡卡槽<rt>stacker</rt></ruby>。這一流程可以保證出卡卡槽中的打孔卡按打孔時的先後順序排列。

029 型打孔機的開關在桌面下膝蓋高度的位置。在開機後，連按兩次 “<ruby>裝入<rt>FEED</rt></ruby>” 鍵讓機器自動將打孔卡從進卡卡槽中取出並移動到機器內。 U 形軌道的底部是打孔機的核心區域，它由三個部分組成：右側是等待區，中間是打孔操作區，左側是閱讀區。連按兩次 “裝入” 鍵，機器就會把一張打孔卡裝入打孔機的打孔操作區，另一張打孔卡進入等待區。在打孔操作區上方有一個列數指示器來顯示當前打孔所在的列的位置。這時，每按下一個按鍵，機器就會在打孔卡對應的位置打孔並在卡片的頂部列印按鍵對應的字元，隨後將打孔卡向左移動一列。如果一張卡片的 80 列全部被打上了資料，這張卡片會被打孔操作區自動釋放並進入閱讀區，同時，一張新的打孔卡會被裝入打孔操作區。如果沒有打完全部的 80 列，可以使用 “<ruby>釋放<rt>REL</rt></ruby>” 鍵完成上面的操作。

在打孔卡上列印對應的字元這一設計讓人很容易分辨出錯誤。但就像密歇根大學的視訊中警告的那樣，打孔卡上修正一個錯誤可不像擦掉一個列印的字元然後再寫上一個新的那樣容易，因為計算機只會根據卡片上的孔來讀取資訊。因為被打出的孔不能被<ruby>復原<rt>unpunched</rt></ruby>，所以並不能直接退回一列然後再打上一個新的字元。打出更多的孔也只能讓這一列的組合變成一個無效字元。IBM 029 型打孔機上雖然有一個可以讓打孔卡回退一列的退格按鍵，但這個按鍵被放置在機器上而非在鍵盤上。這樣的設計也許是為了阻止這個按鍵的使用，因為實際上很少有使用者需要這個功能。

實際上，只有廢棄錯誤的打孔卡再在新的打孔卡上重新打孔這一種修正錯誤的方式。這就是閱讀區的用武之處了。當你發現打孔卡上的第 68 列出錯時，你需要在新的打孔卡上小心的給前 67 列重新打孔，然後給第 68 列打上正確的字母。另一種操作方式是把帶有錯誤資訊的打孔卡放在閱讀區，同時在打孔操作區載入一張新的打孔卡，然後按下 “<ruby>重複<rt>DUP</rt></ruby>” 按鍵直到列數指示器顯示 68 列。這時按下正確的字元來修正錯誤。閱讀區和重複按鍵使得 029 型打孔機很容易複製打孔卡上的內容。當然，這一功能的使用可能有各種各樣的原因，但改錯是最常見的。

（LCTT 譯註：有一種說法是“補丁”這個用於對已經發布的軟體進行修復的術語來源於對打孔紙帶或打孔卡上打錯的孔貼上補丁的做法。可能對於長長的一卷打孔紙帶來說，由於個別字母的錯誤而整個廢棄成本過高，會採用“補丁”的方式；而對於這種單張式的打孔卡來說，重新列印一張正確的更為方便。）

“重複”按鍵允許 029 型打孔機的操作員手動呼叫重複的函數。但是 029 型打孔機還可以設定為自動重複。當用於記錄資料而不是程式設計時，這項功能十分有效。舉個例子，當用打孔卡來記錄大學生的資訊時，每張卡片上都需要輸入學生的宿舍樓的名字，如果發現所輸入資訊的學生都在同一棟樓，就可以使用 029 型打孔機的自動重複功能來完成宿舍樓名稱的填寫。

像這樣的自動化操作可以通過<ruby>程式鼓<rt>program drum</rt></ruby>程式設計到 029 型打孔機裡面。程式鼓就安裝在打孔操作區上方的 U 形軌道中間部分的右上角。通過在打孔卡上寫下程式，然後把打孔卡裝入程式鼓中，就完成了一次給 029 型打孔機的程式設計任務。使用者可以通過這種方式對打孔卡的每一列都按需要定義不同的自動化操作。029 型打孔機允許指定某些列重複上一張打孔卡相同位置的字元，這就是它能更快的輸入學生資訊的理由。它還允許指定某些列只能輸入數字或者字母，指定特定的列為空或者到某一列時就直接跳過一整張打孔卡。程式設計鼓使它在打孔特定列有特殊含義的固定模式卡片時很容易。密歇根大學制作的另一個[進階教學視訊][5]包括了給 029 型打孔機程式設計的過程，如果你已經掌握了它的基礎操作，就快去看看吧。

這會兒，無論你是否看了密歇根大學制作的視訊，都會感嘆打孔機的操作之簡便。雖然修正錯誤的過程很乏味，但除此之外，操作一臺打孔機並不像想象的那樣複雜。我甚至可以想象打孔卡之間的無縫切換讓 COBOL 和 FORTRAN 程式設計師忘記了他們的程式是打在不同的打孔卡上而不是寫在一個連續的文字檔案內。另一方面，思考一下打孔機是如何影響程式語言的發展也是很有趣的，雖然它僅僅是一臺輸入裝置。結構化程式設計最終會出現並鼓勵程式設計師把整個程式碼塊視為一個整體，但可以想象打孔卡程式設計師們強調每一行的作用且難以認同結構化程式設計的場景。同時你能夠理解他們為什麼不把程式碼塊閉合所使用的括號放在單獨的一行，只是因為這樣會浪費打孔卡。

現在，雖然沒有人再使用打孔卡程式設計了，每個程式設計師都該試試[這個][6]，哪怕一次也好。或許你因此能夠更好的理解 COBOL 和 FORTRAN 的歷史，或許你就能體會到為什麼每個人把 80 個字元作為長度限制的標註。

喜歡嗎？這裡每兩週都會發表一篇這樣的文章。請在推特上關注我們 [@TwoBitHistory][7] 或者訂閱我們的 [RSS][8]，這樣你就能在第一時間收到新文章的通知。

[^1]: “IBM 29 Card Punch,” IBM Archives, accessed June 23, 2018, https://www-03.ibm.com/ibm/history/exhibits/vintage/vintage_4506VV4002.html. 
[^2]: IBM, IBM 2540 Component Description and Operation Procedures (Rochester, MN: IBM Product Publications, 1965), September 06, 2009, accessed June 23, 2018, http://bitsavers.informatik.uni-stuttgart.de/pdf/ibm/25xx/A21-9033-1_2540_Card_Punch_Component_Description_1965.pdf. 

--------------------------------------------------------------------------------

via: https://twobithistory.org/2018/06/23/ibm-029-card-punch.html

作者：[Two-Bit History][a]
選題：[lujun9972][b]
譯者：[wwhio](https://github.com/wwhio)
校對：[wxy](https://github.com/wxy)

本文由 [LCTT](https://github.com/LCTT/TranslateProject) 原創編譯，[Linux中國](https://linux.cn/) 榮譽推出

[a]: https://twobithistory.org
[b]: https://github.com/lujun9972
[1]: https://twobithistory.org/images/ibm029_front.jpg
[2]: https://twobithistory.org/images/card.png
[3]: http://www.jkmscott.net/data/Punched%20card%20013.jpg
[4]: https://www.youtube.com/watch?v=kaQmAybWn-w
[5]: https://www.youtube.com/watch?v=SWD1PwNxpoU
[6]: http://www.masswerk.at/keypunch/
[7]: https://twitter.com/TwoBitHistory
[8]: https://twobithistory.org/feed.xml
